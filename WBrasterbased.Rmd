---
title: "Water balance model (rasterbased)"
author: "Niranjan Wimalathunge"
date: "7/2/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning = FALSE)
```

## Introduction
USYD soil water balance model (WBM), a process-based model, caters to soil water dynamics across multiple depth support and scalable farmscapes. The WBM is a multi-layer, knowledge-based model that better represents the vertical soil moisture variation. It is also an unsaturated model where water infiltrates through layers freely and continuously according to the soil properties, determined by the Soil Landscape Grid of Australia (SLGA). Its depth intervals are the model's layer thickness. The corresponding clay, sand and bulk density values were used to calculate the saturated volumetric moisture content (θs) using a pedotransfer function (PTF), which is developed by Padarian et al. (2014). 
The soil is assumed uniform within each horizontal layer, and the water flows through the soil layers vertically. Therefore, the infiltration continues for all layers, and excess soil water beyond the 60–100 cm layer is assumed to be deep drainage and lost to the system as the modelling depth is 1m (root zone). It is also assumed that runoff only occurs when Layer 0–5 cm and Layer 5–15 cm are saturated. Therefore, ET and rainfall required to downscale to 90 m to match with the SLGA resolution. The model is run on each SLGA raster cell daily with the corresponding value for rainfall and evapotranspiration (ET). ET is extracted from layers fully. First, ET is extracted from layer one, and if there a deficit, it is then taken from layer 2. If there still a deficit, it is then taken from the next layer and so on. This method mimics the general behaviour of water extraction by rooting systems of crops.
The model inputs are ET (MODIS 500 m), rainfall (SILO 5 km ) and soil (SLGA 90 m), which can be freely downloadable. This tutorial shows as an example to show how to estimate soil water for an area of interest using the model.

### Getting Started
```{r}
# load required libraries
library(raster)
library(RCurl)
library(rgdal)
library(sp)
library(mapview)
library(viridis)
```

## An example
### Area of interest (Llara,Narrabri )
```{r}
#Llara farm extent
Llara <- readOGR('X:/PRJ-SoilWaterNow/data/Aus/Farms&sites/Llara/Llarashapefile/Farm_boundary_new.shp')
Llara<-spTransform(Llara,CRS("+proj=longlat +datum=WGS84"))
names(Llara)<-"Llara"
mapview(Llara, legend=F)
```

### Get data
Use the [link](https://cloudstor.aarnet.edu.au/plus/apps/files/?dir=/Llara&fileid=5667686166) to download the datasets and change the file paths accordingly

Resolution: ET - 90 m, rain - 90 m and soil: 90 m. 
Duration: 01-01-2001 to 31-12-2020

### covariates 
ET and rainfall datasets were resampled 90 m to match with the SLGA resolution
```{r}
ET <- brick("X:/PRJ-SoilWaterNow/data/Aus/Farms&sites/Llara/LlaraET90m.tif") 
rain <- brick("X:/PRJ-SoilWaterNow/data/Aus/Farms&sites/Llara/LlaraRain90m.tif") 
theta <- brick("X:/PRJ-SoilWaterNow/data/Aus/Farms&sites/Llara/LlaraSoil.tif")

names(ET)<-seq(from=as.Date('2001-01-01'), to=as.Date("2020-12-31"),by='days' )
```

### bucket size
We use pedotranfer function to calculate the water holding capacity using clay and sand content of each layer
```{r}
names(theta)[1:20]<-c( "BDW_005","BDW_015","BDW_030","BDW_060","BDW_100",
                       "CLY_005","CLY_015","CLY_030","CLY_060","CLY_100", 
                       "SLT_005","SLT_015","SLT_030","SLT_060","SLT_100",
                       "SND_005","SND_015","SND_030","SND_060","SND_100")
theta_005 = 0.4795 - 3.873 * 10^-5 * theta$SND_005 ^2 - 6.701 * 10^-7 * theta$CLY_005 ^2 * theta$SND_005
theta_015 = 0.4795 - 3.873 * 10^-5 * theta$SND_015 ^2 - 6.701 * 10^-7 * theta$CLY_015 ^2 * theta$SND_015
theta_030 = 0.4795 - 3.873 * 10^-5 * theta$SND_030 ^2 - 6.701 * 10^-7 * theta$CLY_030 ^2 * theta$SND_030
theta_060 = 0.4795 - 3.873 * 10^-5 * theta$SND_060 ^2 - 6.701 * 10^-7 * theta$CLY_060 ^2 * theta$SND_060
theta_100 = 0.4795 - 3.873 * 10^-5 * theta$SND_100 ^2 - 6.701 * 10^-7 * theta$CLY_100 ^2 * theta$SND_100

pwp_005 = -0.1554 - 0.7221 * tanh(0.5 * (-0.9705 - 0.8529 * theta$BDW_005 - 0.00827 *theta$CLY_005 + 0.01994 * theta$SND_005))  + 0.1325 * tanh(0.5 * (3.71 - 3.19 * theta$BDW_005+ 0.01205 * theta$CLY_005 + 0.01617 * theta$SND_005)) + 0.1720 * tanh(0.5 * (-3.94 - 0.5067 * theta$BDW_005 + 0.02158 * theta$CLY_005 + 0.04978 * theta$SND_005)) 

pwp_015 = -0.1554 - 0.7221 * tanh(0.5 * (-0.9705 - 0.8529 * theta$BDW_015 - 0.00827 *theta$CLY_015 + 0.01994 * theta$SND_015))  + 0.1325 * tanh(0.5 * (3.71 - 3.19 * theta$BDW_015+ 0.01205 * theta$CLY_015 + 0.01617 * theta$SND_015)) + 0.1720 * tanh(0.5 * (-3.94 - 0.5067 * theta$BDW_015 + 0.02158 * theta$CLY_015 + 0.04978 * theta$SND_015)) 

pwp_030 = -0.1554 - 0.7221 * tanh(0.5 * (-0.9705 - 0.8529 * theta$BDW_030 - 0.00827 *theta$CLY_030 + 0.01994 * theta$SND_030))  + 0.1325 * tanh(0.5 * (3.71 - 3.19 * theta$BDW_030+ 0.01205 * theta$CLY_030 + 0.01617 * theta$SND_030)) + 0.1720 * tanh(0.5 * (-3.94 - 0.5067 * theta$BDW_030 + 0.02158 * theta$CLY_030 + 0.04978 * theta$SND_030)) 

pwp_060 = -0.1554 - 0.7221 * tanh(0.5 * (-0.9705 - 0.8529 * theta$BDW_060 - 0.00827 *theta$CLY_060 + 0.01994 * theta$SND_060))  + 0.1325 * tanh(0.5 * (3.71 - 3.19 * theta$BDW_060+ 0.01205 * theta$CLY_060 + 0.01617 * theta$SND_060)) + 0.1720 * tanh(0.5 * (-3.94 - 0.5067 * theta$BDW_060 + 0.02158 * theta$CLY_060 + 0.04978 * theta$SND_060)) 

pwp_100 = -0.1554 - 0.7221 * tanh(0.5 * (-0.9705 - 0.8529 * theta$BDW_100 - 0.00827 *theta$CLY_100 + 0.01994 * theta$SND_100))  + 0.1325 * tanh(0.5 * (3.71 - 3.19 * theta$BDW_100+ 0.01205 * theta$CLY_100 + 0.01617 * theta$SND_100)) + 0.1720 * tanh(0.5 * (-3.94 - 0.5067 * theta$BDW_100 + 0.02158 * theta$CLY_100 + 0.04978 * theta$SND_100)) 

pwp_bucketSize <-stack(pwp_005*50,pwp_015*100,pwp_030*150,pwp_060*300,pwp_100*400)
names(pwp_bucketSize)[1:5]<-c("pwp_005","pwp_015","pwp_030","pwp_060","pwp_100")

# Residual Theta
resid_005<- (0.3697 *tanh (-0.0167 * theta$CLY_005 - 0.0259 * theta$SND_005 + 0.5587 * theta$BDW_005 + 1.86) - 
               0.2543 *tanh (-0.0074 * theta$CLY_005 - 0.0061 * theta$SND_005 + 0.9869 * theta$BDW_005 - 1.47) - 
               0.2099* tanh (-0.0653 * theta$CLY_005 - 0.0063 * theta$SND_005 - 5.3000 * theta$BDW_005 + 9.40) - 0.2032)^2

resid_015<- (0.3697 *tanh (-0.0167 * theta$CLY_015 - 0.0259 * theta$SND_015 + 0.5587 * theta$BDW_015 + 1.86) - 
               0.2543 *tanh (-0.0074 * theta$CLY_015 - 0.0061 * theta$SND_015 + 0.9869 * theta$BDW_015 - 1.47) - 
               0.2099* tanh (-0.0653 * theta$CLY_015 - 0.0063 * theta$SND_015 - 5.3000 * theta$BDW_015 + 9.40) - 0.2032)^2
resid_bucket<-stack(resid_005*50,resid_015*100)

# bucketsize

bucketSize <-stack((fc_005-resid_005)*50,(fc_015-resid_015)*100,(fc_030-pwp_030)*150,
                   (fc_060-pwp_060)*300,(fc_100-pwp_100)*400)

ResRootzone<-resid_005*50+resid_015*100+pwp_030*150+pwp_060*300+pwp_100*400
ResTopsoil<-resid_005*50+resid_015*100+pwp_030*150
```

## The water balance

```{r}
#required plots (important dates which you need soil moisture maps)
#an example (soil water maps for topsoil (0-30 cm), subsoil (30-100 cm) and rootzone (0-100 cm) on 1st of April, 1st August, and 1st December of 2020, representing the start of the crops, full-grown crop and after the harvest soil water conditions)

plotsList<-list("X2020.04.01","X2020.08.01","X2020.12.01")

SM=raster(ET);SM=setValues(SM,0)
SMA1=SM;SMA2=SM;SMA3=SM
SMB1=SM;SMB2=SM;SMB3=SM
SMC1=SM;SMC2=SM;SMC3=SM
SMD1=SM;SMD2=SM;SMD3=SM
SME1=SM;SME2=SM;SME3=SM
runoff=SM; DeepD=SM
SM100=stack();SM30=stack()
ETd=SM # deficit ET

for(a in 1: dim(ET)[3]){
  # 1- current day ; 2-previous day 
  # For example, SMA1(0-5 cm) means  today's soil moisture for 0-5 cm layer whereas SMA2 is previous day soil moisture for 0-5 cm layer
  
  #layer 0-5 cm 
  SMA2=SMA1*.8
  SMA1=SMA1*.2
  
  SMA1= SMA1+rain[[a]]-ET[[a]]*0.125
  
  ETd<- overlay(SMA1,ETd, fun = function(x,y) {i <- x > 0 ;y[i] <- 0;return(y)})
  ETd<- overlay(SMA1,ETd, fun = Vectorize(function(x,y) {i <- x < 0 ;y[i] <- -x;return(y)}))
  SMA1<-calc(SMA1, fun=function(x){ x[x < 0] <- 0; return(x)} )
  
  SMB1<- overlay(SMA1,SMB1,bucketSize[[1]], fun = Vectorize(function(x, y, z) {i <- x > z ;y[i] <- y[i] + (x[i]-z[i]);return(y)})) 
  SMA1<- overlay(SMA1,SMB1,bucketSize[[1]], fun = Vectorize(function(x, y, z) {i <- x > z ;x[i] <- z[i];return(x)}))
  
  #layer 5-15 cm
  SMB2=SMB1*.05
  SMB1=SMB1*.95
  
  SMB1 = SMB1+SMA2-ETd
  
  ETd<- overlay(SMB1,ETd, fun = Vectorize(function(x,y) {i <- x > 0 ;y[i] <- 0;return(y)}))
  ETd<- overlay(SMB1,ETd, fun = Vectorize(function(x,y) {i <- x < 0 ;y[i] <- -x;return(y)}))
  SMB1<-calc(SMB1, fun=function(x){ x[x < 0] <- 0; return(x)})
  
  # if layer 1 and layer 2 full then runoff is the offset of the layer2
  runoff<-overlay(SMA1,SMB1,bucketSize[[1]], bucketSize[[2]],runoff,fun=Vectorize(function(x,y,z,v,w){i<-x==z & y>v;w[i]<-y[i]-v[i];return(w)}))
  SMB1<-overlay(SMB1,SMC1,bucketSize[[2]], fun=Vectorize(function(x,y,z){i<-x>z;x[i]<-z[i];return(x)}))
  
  # else
  SMC1<-overlay(SMB1,SMC1,bucketSize[[2]], fun=Vectorize(function(x,y,z){i<-x>z;y[i]<-y[i]+(x[i]-z[i]);return(y)}))
  SMB1<-overlay(SMB1,SMC1,bucketSize[[2]], fun=Vectorize(function(x,y,z){i<-x>z;x[i]<-z[i];return(x)}))
  
  
  #layer 15-30 cm
  SMC2=SMC1*.05
  SMC1=SMC1*.95
  
  SMC1 = SMC1+SMB2-ETd
  
  ETd<- overlay(SMC1,ETd, fun = Vectorize(function(x,y) {i <- x > 0 ;y[i] <- 0;return(y)}))
  ETd<- overlay(SMC1,ETd, fun = Vectorize(function(x,y) {i <- x < 0 ;y[i] <- -x;return(y)}))
  SMC1<-calc(SMC1, fun=function(x){ x[x < 0] <- 0; return(x)})
  
  SMD1<-overlay(SMC1,SMD1,bucketSize[[3]],fun=Vectorize(function(x,y,z){i<-x>z;y[i]<-y[i]+(x[i]-z[i]);return(y)}))
  SMC1<-overlay(SMC1,SMD1,bucketSize[[3]],fun=Vectorize(function(x,y,z){i<-x>z;x[i]<-z[i];return(x)}))
  
  #layer 30-60 cm
  SMD2=SMD1*.01
  SMD1=SMD1*.99
  
  SMD1 = SMD1+ SMC2-ETd
  
  ETd<- overlay(SMD1,ETd, fun = Vectorize(function(x,y) {i <- x > 0 ;y[i] <- 0;return(y)}))
  ETd<- overlay(SMD1,ETd, fun = Vectorize(function(x,y) {i <- x < 0 ;y[i] <- -x;return(y)}))
  SMD1<-calc(SMD1, fun=function(x){ x[x < 0] <- 0; return(x)})
  
  SME1<-overlay(SMD1,SME1,bucketSize[[4]],fun=Vectorize(function(x,y,z){i<-x>z;y[i]<-y[i]+(x[i]-z[i]);return(y)}))
  SMD1<-overlay(SMD1,SME1,bucketSize[[4]],fun=Vectorize(function(x,y,z){i<-x>z;x[i]<-z[i];return(x)}))
  
  #layer 60-100 cm
  SME2=SME1*.01
  SME1=SME1*.99
  
  SME1 = SME1+ SMD2-ETd
  
  ETd<- overlay(SME1,ETd, fun = Vectorize(function(x,y) {i <- x > 0 ;y[i] <- 0;return(y)}))
  ETd<- overlay(SME1,ETd, fun = Vectorize(function(x,y) {i <- x < 0 ;y[i] <- -x;return(y)}))
  SME1<-calc(SME1, fun=function(x){ x[x < 0] <- 0; return(x)})
  
  DeepD<-overlay(SME1,DeepD,bucketSize[[5]],fun=Vectorize(function(x,y,z){i<-x>z;y[i]<-y[i]+(x[i]-z[i]);return(y)}))
  SME1<-overlay(SME1,DeepD,bucketSize[[5]],fun=Vectorize(function(x,y,z){i<-x>z;x[i]<-z[i];return(x)}))
  
  # stack only rasters in the plotsList 
  # SM30 is topsoil and SM100 is rootzone soil moisture
  
  if (names(ET[[a]]) %in% plotsList==TRUE){ 
      SM30=stack(SM30,(SMA1+SMB1+SMC1))
      SM100=stack(SM100,(SMA1+SMB1+SMC1+SMD1+SME1))}
  # we are not keeping the outputs of runoff and deep drainage but it is possible
  runoff=setValues(runoff, 0)
  DeepD=setValues(DeepD, 0)
  ETd=setValues(ETd,0)
  a=a+1
  
}

```

## Plot the current soil moisture
```{r}
names(SM30)<-plotsList
names(SM100)<-plotsList
spplot(SM30, col.regions=viridis(100),main="Topsoil moisture")
spplot(SM100, col.regions=viridis(100),main="Rootzone moisture")
spplot(SM100-SM30, col.regions=viridis(100),main="Subsoil moisture")
```
