---
title: "Water balance model (rasterbased)"
description: time-series of soil water rasters  
author: "Niranjan Wimalathunge"
date: "7/2/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning = FALSE)
```

## Introduction
USYD soil water balance model (WBM), a process-based model, caters to soil water dynamics across multiple depth support and scalable farmscapes. The WBM is a multi-layer, knowledge-based model that better represents the vertical soil moisture variation. It is also an unsaturated model where water infiltrates through layers freely and continuously according to the soil properties, determined by the Soil Landscape Grid of Australia (SLGA). Its depth intervals are the model's layer thickness. The corresponding clay, sand and bulk density values were used to calculate the saturated volumetric moisture content (θs) using a pedotransfer function (PTF), which is developed by Padarian et al. (2014). 
The soil is assumed uniform within each horizontal layer, and the water flows through the soil layers vertically. Therefore, the infiltration continues for all layers, and excess soil water beyond the 60–100 cm layer is assumed to be deep drainage and lost to the system as the modelling depth is 1m (root zone). It is also assumed that runoff only occurs when Layer 0–5 cm and Layer 5–15 cm are saturated. Therefore, ET and rainfall required to downscale to 90 m to match with the SLGA resolution. The model is run on each SLGA raster cell daily with the corresponding value for rainfall and evapotranspiration (ET). ET is extracted from layers fully. First, ET is extracted from layer one, and if there a deficit, it is then taken from layer 2. If there still a deficit, it is then taken from the next layer and so on. This method mimics the general behaviour of water extraction by rooting systems of crops.

### Getting Started
```{r,warning=FALSE,message=FALSE}
# load required libraries
library(raster)
library(RCurl)
library(rgdal)
library(sp)
library(mapview)
library(viridis)
```

## An example
### Area of interest (Llara)
```{r,message=FALSE}
#Llara farm extent
Llara <- readOGR('C:/Users/nman2690/OneDrive - The University of Sydney (Staff)/Llara/LlaraWB/Llarashapefile/Farm_boundary_new.shp')
Llara<-spTransform(Llara,CRS("+proj=longlat +datum=WGS84"))
names(Llara)<-"Llara"
mapview(Llara, legend=F)
```

### Get data
Use the [link](https://unisyd-my.sharepoint.com/:f:/r/personal/niranjan_manikkuacharige_sydney_edu_au/Documents/Llara/LlaraWB?csf=1&web=1&e=tDHxmB) to download the datasets and change the file paths accordingly

### covariates 
The model inputs derive from 8-day ET (MODIS 500 m), daily rainfall (SILO 5 km ) and soil (SLGA 90 m), which can be freely downloadable. This tutorial shows as an example to show how to estimate soil water for an area of interest using the model.

ET: 8-day ET convert to daily assuming ET is uniform and resample to 90 m to match with the SLGA 
rain: resample to 90 m to match with the SLGA  
Duration: 01-01-2001 to 31-12-2021

Model run:01-01-2016 to 31-12-2021 
```{r}
ET <- brick("C:/Users/nman2690/OneDrive - The University of Sydney (Staff)/Llara/LlaraWB/LlaraET01-21_90m.tif")[[5479:7670]]
rain <- brick("C:/Users/nman2690/OneDrive - The University of Sydney (Staff)/Llara/LlaraWB/LlaraRain01-21_90m.tif")[[5479:7670]] 
theta <- brick("C:/Users/nman2690/OneDrive - The University of Sydney (Staff)/Llara/LlaraWB/LlaraSoil.tif")
```

### bucket size
We use pedotranfer function to calculate the water holding capacity (drained upper limit (DUL) using clay and sand content of each layer
```{r}
names(theta)[1:20]<-c( "BDW_005","BDW_015","BDW_030","BDW_060","BDW_100",
                       "CLY_005","CLY_015","CLY_030","CLY_060","CLY_100", 
                       "SLT_005","SLT_015","SLT_030","SLT_060","SLT_100",
                       "SND_005","SND_015","SND_030","SND_060","SND_100")
fc_005 = 0.4795 - 3.873 * 10^-5 * theta$SND_005 ^2 - 6.701 * 10^-7 * theta$CLY_005 ^2 * theta$SND_005
fc_015 = 0.4795 - 3.873 * 10^-5 * theta$SND_015 ^2 - 6.701 * 10^-7 * theta$CLY_015 ^2 * theta$SND_015
fc_030 = 0.4795 - 3.873 * 10^-5 * theta$SND_030 ^2 - 6.701 * 10^-7 * theta$CLY_030 ^2 * theta$SND_030
fc_060 = 0.4795 - 3.873 * 10^-5 * theta$SND_060 ^2 - 6.701 * 10^-7 * theta$CLY_060 ^2 * theta$SND_060
fc_100 = 0.4795 - 3.873 * 10^-5 * theta$SND_100 ^2 - 6.701 * 10^-7 * theta$CLY_100 ^2 * theta$SND_100
```

Permanent wilting point use as the lower bounds for moisture extraction (by plants) 
```{r}
pwp_005 = -0.1554 - 0.7221 * tanh(0.5 * (-0.9705 - 0.8529 * theta$BDW_005 - 0.00827 *theta$CLY_005 + 0.01994 * theta$SND_005))  + 0.1325 * tanh(0.5 * (3.71 - 3.19 * theta$BDW_005+ 0.01205 * theta$CLY_005 + 0.01617 * theta$SND_005)) + 0.1720 * tanh(0.5 * (-3.94 - 0.5067 * theta$BDW_005 + 0.02158 * theta$CLY_005 + 0.04978 * theta$SND_005)) 

pwp_015 = -0.1554 - 0.7221 * tanh(0.5 * (-0.9705 - 0.8529 * theta$BDW_015 - 0.00827 *theta$CLY_015 + 0.01994 * theta$SND_015))  + 0.1325 * tanh(0.5 * (3.71 - 3.19 * theta$BDW_015+ 0.01205 * theta$CLY_015 + 0.01617 * theta$SND_015)) + 0.1720 * tanh(0.5 * (-3.94 - 0.5067 * theta$BDW_015 + 0.02158 * theta$CLY_015 + 0.04978 * theta$SND_015)) 

pwp_030 = -0.1554 - 0.7221 * tanh(0.5 * (-0.9705 - 0.8529 * theta$BDW_030 - 0.00827 *theta$CLY_030 + 0.01994 * theta$SND_030))  + 0.1325 * tanh(0.5 * (3.71 - 3.19 * theta$BDW_030+ 0.01205 * theta$CLY_030 + 0.01617 * theta$SND_030)) + 0.1720 * tanh(0.5 * (-3.94 - 0.5067 * theta$BDW_030 + 0.02158 * theta$CLY_030 + 0.04978 * theta$SND_030)) 

pwp_060 = -0.1554 - 0.7221 * tanh(0.5 * (-0.9705 - 0.8529 * theta$BDW_060 - 0.00827 *theta$CLY_060 + 0.01994 * theta$SND_060))  + 0.1325 * tanh(0.5 * (3.71 - 3.19 * theta$BDW_060+ 0.01205 * theta$CLY_060 + 0.01617 * theta$SND_060)) + 0.1720 * tanh(0.5 * (-3.94 - 0.5067 * theta$BDW_060 + 0.02158 * theta$CLY_060 + 0.04978 * theta$SND_060)) 

pwp_100 = -0.1554 - 0.7221 * tanh(0.5 * (-0.9705 - 0.8529 * theta$BDW_100 - 0.00827 *theta$CLY_100 + 0.01994 * theta$SND_100))  + 0.1325 * tanh(0.5 * (3.71 - 3.19 * theta$BDW_100+ 0.01205 * theta$CLY_100 + 0.01617 * theta$SND_100)) + 0.1720 * tanh(0.5 * (-3.94 - 0.5067 * theta$BDW_100 + 0.02158 * theta$CLY_100 + 0.04978 * theta$SND_100)) 

pwp_bucketSize <-stack(pwp_005*50,pwp_015*100,pwp_030*150,pwp_060*300,pwp_100*400)
names(pwp_bucketSize)[1:5]<-c("pwp_005","pwp_015","pwp_030","pwp_060","pwp_100")
```
The minimum soil water in surface layers (0-5, 5-15 cm) determine by the residual moisture content 

```{r}

# Residual Theta
resid_005<- (0.3697 *tanh (-0.0167 * theta$CLY_005 - 0.0259 * theta$SND_005 + 0.5587 * theta$BDW_005 + 1.86) - 
               0.2543 *tanh (-0.0074 * theta$CLY_005 - 0.0061 * theta$SND_005 + 0.9869 * theta$BDW_005 - 1.47) - 
               0.2099* tanh (-0.0653 * theta$CLY_005 - 0.0063 * theta$SND_005 - 5.3000 * theta$BDW_005 + 9.40) - 0.2032)^2

resid_015<- (0.3697 *tanh (-0.0167 * theta$CLY_015 - 0.0259 * theta$SND_015 + 0.5587 * theta$BDW_015 + 1.86) - 
               0.2543 *tanh (-0.0074 * theta$CLY_015 - 0.0061 * theta$SND_015 + 0.9869 * theta$BDW_015 - 1.47) - 
               0.2099* tanh (-0.0653 * theta$CLY_015 - 0.0063 * theta$SND_015 - 5.3000 * theta$BDW_015 + 9.40) - 0.2032)^2
resid_bucket<-stack(resid_005*50,resid_015*100)

# PAW - Plant available water

bucketSize <-stack((fc_005-resid_005)*50,(fc_015-resid_015)*100,(fc_030-pwp_030)*150,
                   (fc_060-pwp_060)*300,(fc_100-pwp_100)*400)

# water not access to plants
ResRootzone<-resid_005*50+resid_015*100+pwp_030*150+pwp_060*300+pwp_100*400
ResTopsoil<-resid_005*50+resid_015*100+pwp_030*150
```

## The water balance

```{r}
SM=raster(ET);SM=setValues(SM,0)
SMA1=SM;SMA2=SM;SMA3=SM
SMB1=SM;SMB2=SM;SMB3=SM
SMC1=SM;SMC2=SM;SMC3=SM
SMD1=SM;SMD2=SM;SMD3=SM
SME1=SM;SME2=SM;SME3=SM
runoff=SM; DeepD=SM
SM100total=stack();SM30total=stack()
SM30paw=stack();SM100paw=stack()
ETd=SM # deficit ET

for(a in 1:dim(ET)[3]){
  
  #layer 0-5 cm 
  SMA2=SMA1*.8
  SMA1=SMA1*.2
  
  SMA1= SMA1+rain[[a]]-(ET[[a]])*0.125
  
  ETd<- overlay(SMA1,ETd, fun = function(x,y) {i <- x > 0 ;y[i] <- 0;return(y)})
  ETd<- overlay(SMA1,ETd, fun = Vectorize(function(x,y) {i <- x < 0 ;y[i] <- -x;return(y)}))
  SMA1<-calc(SMA1, fun=function(x){ x[x < 0] <- 0; return(x)} )
  
  SMB1<- overlay(SMA1,SMB1,bucketSize[[1]], fun = Vectorize(function(x, y, z) {i <- x > z ;y[i] <- y[i] + (x[i]-z[i]);return(y)})) 
  SMA1<- overlay(SMA1,SMB1,bucketSize[[1]], fun = Vectorize(function(x, y, z) {i <- x > z ;x[i] <- z[i];return(x)}))
  
  #layer 5-15 cm
  SMB2=SMB1*.05
  SMB1=SMB1*.95
  
  SMB1 = SMB1+SMA2-ETd
  
  ETd<- overlay(SMB1,ETd, fun = Vectorize(function(x,y) {i <- x > 0 ;y[i] <- 0;return(y)}))
  ETd<- overlay(SMB1,ETd, fun = Vectorize(function(x,y) {i <- x < 0 ;y[i] <- -x;return(y)}))
  SMB1<-calc(SMB1, fun=function(x){ x[x < 0] <- 0; return(x)})
  
  # if layer 1 and layer 2 full then runoff is the offset of the layer2
  runoff<-overlay(SMA1,SMB1,bucketSize[[1]], bucketSize[[2]],runoff,fun=Vectorize(function(x,y,z,v,w){i<-x==z & y>v;w[i]<-y[i]-v[i];return(w)}))
  SMB1<-overlay(SMB1,SMC1,bucketSize[[2]], fun=Vectorize(function(x,y,z){i<-x>z;x[i]<-z[i];return(x)}))
  
  # else
  SMC1<-overlay(SMB1,SMC1,bucketSize[[2]], fun=Vectorize(function(x,y,z){i<-x>z;y[i]<-y[i]+(x[i]-z[i]);return(y)}))
  SMB1<-overlay(SMB1,SMC1,bucketSize[[2]], fun=Vectorize(function(x,y,z){i<-x>z;x[i]<-z[i];return(x)}))
  
  
  #layer 15-30 cm
  SMC2=SMC1*.05
  SMC1=SMC1*.95
  
  SMC1 = SMC1+SMB2-ETd
  
  ETd<- overlay(SMC1,ETd, fun = Vectorize(function(x,y) {i <- x > 0 ;y[i] <- 0;return(y)}))
  ETd<- overlay(SMC1,ETd, fun = Vectorize(function(x,y) {i <- x < 0 ;y[i] <- -x;return(y)}))
  SMC1<-calc(SMC1, fun=function(x){ x[x < 0] <- 0; return(x)})
  
  SMD1<-overlay(SMC1,SMD1,bucketSize[[3]],fun=Vectorize(function(x,y,z){i<-x>z;y[i]<-y[i]+(x[i]-z[i]);return(y)}))
  SMC1<-overlay(SMC1,SMD1,bucketSize[[3]],fun=Vectorize(function(x,y,z){i<-x>z;x[i]<-z[i];return(x)}))
  
  #layer 30-60 cm
  SMD2=SMD1*.01
  SMD1=SMD1*.99
  
  SMD1 = SMD1+ SMC2-ETd
  
  ETd<- overlay(SMD1,ETd, fun = Vectorize(function(x,y) {i <- x > 0 ;y[i] <- 0;return(y)}))
  ETd<- overlay(SMD1,ETd, fun = Vectorize(function(x,y) {i <- x < 0 ;y[i] <- -x;return(y)}))
  SMD1<-calc(SMD1, fun=function(x){ x[x < 0] <- 0; return(x)})
  
  SME1<-overlay(SMD1,SME1,bucketSize[[4]],fun=Vectorize(function(x,y,z){i<-x>z;y[i]<-y[i]+(x[i]-z[i]);return(y)}))
  SMD1<-overlay(SMD1,SME1,bucketSize[[4]],fun=Vectorize(function(x,y,z){i<-x>z;x[i]<-z[i];return(x)}))
  
  #layer 60-100 cm
  SME2=SME1*.01
  SME1=SME1*.99
  
  SME1 = SME1+ SMD2-ETd
  
  ETd<- overlay(SME1,ETd, fun = Vectorize(function(x,y) {i <- x > 0 ;y[i] <- 0;return(y)}))
  ETd<- overlay(SME1,ETd, fun = Vectorize(function(x,y) {i <- x < 0 ;y[i] <- -x;return(y)}))
  SME1<-calc(SME1, fun=function(x){ x[x < 0] <- 0; return(x)})
  
  DeepD<-overlay(SME1,DeepD,bucketSize[[5]],fun=Vectorize(function(x,y,z){i<-x>z;y[i]<-y[i]+(x[i]-z[i]);return(y)}))
  SME1<-overlay(SME1,DeepD,bucketSize[[5]],fun=Vectorize(function(x,y,z){i<-x>z;x[i]<-z[i];return(x)}))
  
  #select either Total water or Paw water and save
  SM30total=stack(SM30total,(SMA1+SMB1+SMC1+ResTopsoil))# Total water
  SM100total=stack(SM100total,(SMA1+SMB1+SMC1+SMD1+SME1+ResRootzone))# Total water
  
  ##SM30paw=stack(SM30paw,(SMA1+SMB1+SMC1))# Plant available water
  #SM100paw=stack(SM100paw,(SMA1+SMB1+SMC1+SMD1+SME1))# plant available water
  
  runoff=setValues(runoff, 0)
  DeepD=setValues(DeepD, 0)
  ETd=setValues(ETd,0)
  a=a+1
  
}

#writeRaster(SM100total, filename='X:/PRJ-SoilWaterNow/data/Aus/Farms&sites/Llara/SM100total.tif', format="GTiff", overwrite=TRUE,options=c("INTERLEAVE=BAND","COMPRESS=LZW"))

```

### Plot the soil moisture
Required plots:important dates which you need soil moisture maps
Example: soil water maps for rootzone (0-100 cm) on 1st of April, 1st July, of 2020, representing the start of the crops, full-grown crop soil water conditions

```{r}
setwd("X:/PRJ-Muttama/R")
names(SM100total)<-seq(from=as.Date('2016-01-01'), to=as.Date("2021-12-31"),by='days' )
requested<-SM100total[[grep("2021.04.01|2021.07.01",names(SM100total))]]

boundary.layer <- list("sp.lines", Llara, col = "green")
spplot(requested,sp.layout = boundary.layer,col.regions=viridis(100),main="Total soil water (Rootzone)",scales = list(draw = TRUE))

```
